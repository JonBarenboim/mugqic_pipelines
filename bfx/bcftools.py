#!/usr/bin/env python

################################################################################
# Copyright (C) 2014, 2015 GenAP, McGill University and Genome Quebec Innovation Centre
#
# This file is part of MUGQIC Pipelines.
#
# MUGQIC Pipelines is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MUGQIC Pipelines is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with MUGQIC Pipelines.  If not, see <http://www.gnu.org/licenses/>.
################################################################################

# Python Standard Modules

# MUGQIC Modules
from core.config import *
from core.job import *

def add_reject(input, output):
    """
    Adds REJECT to the filter. Used with scalpel when merging common indels
    """
    return Job(
        [input],
        [output],
        [
            ['bcftools_add_reject', 'module_bcftools']
        ],
        command="""\
bcftools \\
  filter -m '+' -O v --soft-filter 'REJECT' -e '%TYPE="indel"' \\
  {input}{output}""".format(
        input=input,
        output=" \\\n  > " + output if output else ""
        )
    )

def add_chi2Filter(input, output):
    """
    Adds CHI2FILTER to the filter. Used with scalpel on somatic indels
    """
    return Job(
        [input],
        [output],
        [
            ['bcftools_add_chi2Filter', 'module_bcftools']
        ],
        command="""\
bcftools \\
  filter -m '+' -O v --soft-filter 'CHI2FILTER' -e 'INFO/CHI2 > 20.0' \\
  {input}{output}""".format(
        input=input,
        output=" \\\n  > " + output if output else ""
        )
    )


def norm(input, output, options="", ini_section="bcftools_norm"):
    
    return Job(
        [input],
        [output],
        [['bcftools_norm', 'module_bcftools']],
        command="""\
bcftools \\
  norm {options}\\
  -o {output} \\
  {input}""".format(
        options=options + " " if options else "",
        input=input,
        output=output
        )
    )


# BCFTOOLS VIEW FUNCTION -- for samtools >0.1.19
def view(input, output, options="", ini_section="bcftools_view"):

    return Job(
        [input],
        [output],
        [['bcftools_view', 'module_bcftools']],
        command="""\
bcftools \\
  view {options}\\
  {input}{output}""".format(
        options=options + " " if options else "",
        input=input,
        output=" \\\n  -o " + output if output else ""
        )
    )


def multiToIndivVQSR(input, output):
    """
    Break down a multiple-sample VQSR file generated by "variant-recalibrator" step into invidual
	sample files 
    """
    return Job(
        [input],
	[output],
        [
            ['bcftools_view', 'module_bcftools']
        ],
        command="""\
for sample in $(bcftools view -h {input} | grep "^#CHROM" | cut -f10-); do \\
    mkdir -p variants/$sample && \\
    bcftools view -c1 -Ov -s $sample -o variants/$sample/$sample.hc.vqsr.vcf {input}; \\
done""".format( 
        input=input
        )
    )

# compared to the above function, this one works on individual samples as provided in the "sample" parameter
def multiToIndivVQSR2(input, sample,  output):
    """
    Break down a multiple-sample VQSR file generated by "variant-recalibrator" step into invidual
	sample files 
    """
    return Job(
        [input],
	[output],
        [
            ['bcftools_view', 'module_bcftools']
        ],
        command="""\
mkdir -p variants/{sample} && \\
bcftools view -c1 -Ov -s {sample} -o variants/{sample}/{sample}.hc.vqsr.vcf {input} \\
""".format( 
        input=input,
	sample=sample
        )
    )


def multiToIndivGenotype(input, sample,  output):
    """
    Break down a multiple-sample Genotype file generated by "merge_and_call_combined_gvcf" step into invidual
	sample files 
    """
    return Job(
        [input],
	[output],
        [
            ['bcftools_view', 'module_bcftools']
        ],
        command="""\
mkdir -p variants/{sample} && \\
bcftools view -c1 -Ov -s {sample} -o variants/{sample}/{sample}.hc.indivGT.vcf {input} \\
""".format( 
        input=input,
	sample=sample
        )
    )


# sample name is provided in the "inputVCF1" and "inputVCF2". "sample" parameter is used to indicate the output folder location
def intersect(inputVCF1, inputVCF2, sample, output):
    """
    Find the intersection of "sample.PASSvqsr.vcf" file with the "sample.hc.vcf" gvcf file of each sample. The latter file
           contains the original DP, MQ, etc. parameters. 
    "bcftools isec" generates 4 files in the folder specified by the "-p" parameter. These are:
    0000.vcf	variants private to "sample.hc.PASSvqsr.vcf.gz"
    0001.vcf	variants private to "sample.hc.vcf.gz"
    0002.vcf	variants in "sample.hc.PASSvqsr.vcf.gz" that are shared in both files (intersection)
    0003.vcf	variants in "sample.hc.vcf.gz" that are shared in both files

    here 0002.vcf and 0003.vcf are the intersections of the two files but we want 0002.vcf which are the records in "sample.PASSvqsr.vcf"
    that are shared between the two files. Using the "cp" function below we attach the sample name to it
    """
    return Job(
        [inputVCF1, inputVCF2],
	[output],
        [
            ['bcftools_view', 'module_bcftools']
        ],
        command="""\
bcftools isec -p variants/{sample}/ -c all {inputVCF1} {inputVCF2} \\
&& cp variants/{sample}/0002.vcf {output}""".format(
	sample=sample,
	inputVCF1=inputVCF1,
	inputVCF2=inputVCF2,
        output=" \\\n  " + output if output else ""
        )
    )



